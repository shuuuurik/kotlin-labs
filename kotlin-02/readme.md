###<p style="text-align: center;">Функции и функциональные интерфейсы в Kotlin</p>

---

####Задача № 1: Обработка функционального типа
Реализуйте функцию, которая принимает функциональный тип в качестве аргумента и вызывает его несколько раз

Сигнатура функционального типа:

```
(Int) -> Unit
```

Сигнатура функции:

```kotlin
fun callTwice(expression: (Int) -> Unit) { }
```

Данная функция должна вызывать функциональное выражение дважды. В первый раз передавать число `4`, во второй раз — `41`.

Вызовите данную функцию три раза.

* В первый раз передайте ей лямбда-выражение, которое выводит переданный аргумент на стандартный поток вывода. Ожидаемый вывод:
  ```
  4
  41
  ```

* Во второй раз передайте ей лямбда-выражение, которое умножает переданный аргумент на 2 и выводит результат на стандартный поток вывода.
  ```
  8
  82
  ```

* В третий раз передайте ей лямбда-выражение, которое выводит на стандартный поток слово «нечётное», если в качестве аргумента было передано нечётное число, и «чётное» в остальных случаях.
  ```
  чётное
  нечётное
  ```

---

####Задача № 2: Обработка результатов вызова функционального типа
Реализуйте, функцию, которая будет вызывать функциональное выражение и выводить результат обработки данных на стандартный поток вывода. Сигнатура функционального типа:
```
(Double) -> Double
```
Сигнатура функции:
```kotlin
fun callAndPrint(expression: (Double) -> Double) {}
```
Данная функция должна вызывать функциональное выражение трижды. С аргументами: `25`, `16`, `157`.

* Вызовите данную функцию, передав ей лямбда-выражение, которое вычисляет остаток от деления аргумента на `13`. Ожидаемый вывод:
  ```
  12
  3
  1
  ```
* Вызовите данную функцию, передав ей лямбда-выражение, которое возводит аргумент во вторую степень. Ожидаемый вывод:
  ```
  625
  256
  24649
  ```

---

####Задача № 3: Динамическое создание лямбда-выражений
Создайте функцию — генератор лямбда-выражений. Данная функция в качестве аргумента должна принимать вещественное число, а в качестве результата возвращать лямда-выражение, сигнатура которого соответствует требованиям из задачи № 2.

Создаваемые лямбда-выражения должны умножать переданный им аргумент на значение, которое передаётся в качестве аргумента основной функции.

Сигнатура функции-генератора:
```kotlin
fun createMultiplier(coefficient: Double): (Double) -> Double { ... }
```
Реализуйте данную функцию с использованием `return`-выражения и без него.

Используйте функцию-генератор и функцию, работающую с функциональными выражениями из задачи № 2.

* Вызовите функцию из задачи № 2, передав ей лямбда-выражение, созданное путём вызова функции-генератора с коэффициентом, равным 10. Ожидаемый вывод:
  ```
  250
  160
  1570
  ```
* Вызовите функцию из задачи № 2, передав ей лямбда-выражение, созданное путём вызова функции-генератора с коэффициентом, равным 7. Ожидаемый вывод:
  ```
  175
  112
  1099
  ```
Создайте лямбда-выражение путём вызова функции-генератора с коэффициентом 1. Создайте ещё одно лямбда-выражение путём вызова функции-генератора с коэффициентом 1. Являются ли данные лямбда-выражения одинаковыми? Будет ли результат вызова данных лямбда-выражений одинаковым?

####Задача № 4: Определение функционального (SAM) интерфейса
Определите функциональный интерфейс для описания функционального типа. Интерфейс может быть назван `DoubleTransformer`. Сигнатура функционального метода может иметь следующий вид:
```kotlin
fun transform(number: Double): Double
```
* В местах вхождения функционального типа `(Double) -> Double` замените его на использование функционального интерфейса.
* Удостоверьтесь, что приложение корректно функционирует.
* В каком случае с точки зрения исходного кода следует использовать описание функционального типа, а в каких случаях подходит функциональный интерфейс?

####Задача № 5: Наследование от функционального интерфейса в классах
Определите класс, задачей которого является вычисление значения многочлена в определённой точки. В качестве данных классу передаётся список коэффициентов многочлена, начиная с наименьшего. Класс должен реализовывать функциональный интерфейс, описанный в задаче № 4. Предположим, что данный класс называется `PolynomialCalculator`.

Создайте экземпляр данного класса, передав ему в качестве списка коэффициентов следующий список:
```
listOf(7, -5, 2)
```
Вызовите функцию ~~`calcAndPrint` из задачи № 2~~ `calcAndPrint2` из задачи № 4, передав ей в качестве аргумента созданный экземпляр класса `PolynomialCalculator`. В результате работы метода должен получиться вывод:
  ```
  1132
  439
  48520
  ```